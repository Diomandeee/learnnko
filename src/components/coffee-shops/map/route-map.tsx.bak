import { useEffect, useState, useCallback } from "react" 
import { format } from "date-fns"
import { Button } from "@/components/ui/button"
import { Card } from "@/components/ui/card"
import { RadioGroup, RadioGroupItem } from "@/components/ui/radio-group"
import { Label } from "@/components/ui/label"
import { NavigationPanel } from "./navigation-panel"
import { Car, Navigation, Badge, RefreshCw, ChevronLeft, ChevronRight, Map, User, Lock } from "lucide-react"
import { cn } from "@/lib/utils"
import { useToast } from "@/components/ui/use-toast"
import { Alert, AlertDescription } from "@/components/ui/alert"

declare global {
 interface Window {
   google: typeof google
   initMap: () => void
 }
}

interface RouteStep {
 instructions: string
 distance: string
 duration: string
 maneuver?: string
 start_location: google.maps.LatLng
}


export default function RouteMap({ sourceShop, nearbyShops, maxDistance, onRouteCalculated }) {
  const [map, setMap] = useState<google.maps.Map | null>(null)
  const [directionsService, setDirectionsService] = useState<google.maps.DirectionsService | null>(null)
  const [directionsRenderer, setDirectionsRenderer] = useState<google.maps.DirectionsRenderer | null>(null)
  const [userMarker, setUserMarker] = useState<google.maps.Marker | null>(null)
  const [shopMarkers, setShopMarkers] = useState<google.maps.Marker[]>([])
  const [infoWindows, setInfoWindows] = useState<google.maps.InfoWindow[]>([])
  const [isCalculating, setIsCalculating] = useState(false)
  const [navigationMode, setNavigationMode] = useState(false)
  const [currentStep, setCurrentStep] = useState(0)
  const [routeSteps, setRouteSteps] = useState<RouteStep[]>([])
  const [transportMode, setTransportMode] = useState<'DRIVING' | 'WALKING'>('DRIVING')
  const [isAtDestination, setIsAtDestination] = useState(false)
  const [estimatedArrival, setEstimatedArrival] = useState<string | null>(null)
  const [timeRemaining, setTimeRemaining] = useState<string | null>(null)
  const [userLocation, setUserLocation] = useState<google.maps.LatLngLiteral | null>(null)
  const [watchId, setWatchId] = useState<number | null>(null)
  const [locationEnabled, setLocationEnabled] = useState(false)
  const [showUserLocation, setShowUserLocation] = useState(false)
  const [locationError, setLocationError] = useState<string | null>(null)
  const [isIOS, setIsIOS] = useState(false)
  const [hasLocationPermission, setHasLocationPermission] = useState(false)
  const [permissionStatus, setPermissionStatus] = useState<PermissionState>('prompt')
  const { toast } = useToast()
 

  // Define calculateRoute first before using it in other functions
  const calculateRoute = useCallback(async () => {
    if (!directionsService || !directionsRenderer || nearbyShops.length === 0) return
    if (!userLocation && !hasLocationPermission) {
      const granted = await requestLocationPermission()
      if (!granted) return
    }
 
    setIsCalculating(true)
 
    try {
      const waypoints = nearbyShops.map(shop => ({
        location: { lat: shop.latitude, lng: shop.longitude },
        stopover: true
      }))
 
      const origin = userLocation || { lat: sourceShop.latitude, lng: sourceShop.longitude }
 
      const request = {
        origin,
        destination: { lat: sourceShop.latitude, lng: sourceShop.longitude },
        waypoints,
        optimizeWaypoints: true,
        travelMode: transportMode === 'WALKING' ? 
          google.maps.TravelMode.WALKING : 
          google.maps.TravelMode.DRIVING,
      }
 
      const result = await new Promise<google.maps.DirectionsResult>((resolve, reject) => {
        directionsService.route(request, (result, status) => {
          if (status === 'OK') resolve(result)
          else reject(new Error(`Directions failed: ${status}`))
        })
      })
 
      directionsRenderer.setDirections(result)
      const allSteps: RouteStep[] = []
      let totalDuration = 0
      
      result.routes[0].legs.forEach(leg => {
        totalDuration += leg.duration!.value
        leg.steps.forEach(step => {
          allSteps.push({
            instructions: step.instructions,
            distance: step.distance!.text,
            duration: step.duration!.text,
            maneuver: step.maneuver,
            start_location: step.start_location
          })
        })
      })
 
      const arrivalTime = new Date(Date.now() + totalDuration * 1000)
      setEstimatedArrival(format(arrivalTime, 'h:mm a'))
      
      const hours = Math.floor(totalDuration / 3600)
      const minutes = Math.floor((totalDuration % 3600) / 60)
      setTimeRemaining(hours > 0 ? `${hours}h ${minutes}m` : `${minutes}m`)
 
      setRouteSteps(allSteps)
      onRouteCalculated?.(nearbyShops)
 
    } catch (error) {
      console.error('Route calculation error:', error)
      toast({
        title: "Error",
        description: "Failed to calculate route.",
        variant: "destructive"
      })
    } finally {
      setIsCalculating(false)
    }
  }, [directionsService, directionsRenderer, sourceShop, nearbyShops, transportMode, userLocation, hasLocationPermission, requestLocationPermission])
 
 useEffect(() => {
   const iOSDevice = /iPad|iPhone|iPod/.test(navigator.platform) || 
     (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1)
   setIsIOS(iOSDevice)
 }, [])

 useEffect(() => {
   const checkPermission = async () => {
     try {
       const permission = await navigator.permissions.query({ name: 'geolocation' })
       setPermissionStatus(permission.state)
       setHasLocationPermission(permission.state === 'granted')
       
       permission.addEventListener('change', () => {
         setPermissionStatus(permission.state)
         setHasLocationPermission(permission.state === 'granted')
       })
     } catch (error) {
       console.error('Permission check error:', error)
     }
   }
   checkPermission()
 }, [])

 const cleanupMarkers = useCallback(() => {
   shopMarkers.forEach(marker => marker.setMap(null))
   setShopMarkers([])
   infoWindows.forEach(window => window.close())
   setInfoWindows([])
   if (userMarker) {
     userMarker.setMap(null)
     setUserMarker(null)
   }
 }, [shopMarkers, infoWindows, userMarker])

 const requestLocationPermission = useCallback(async () => {
   setLocationError(null)
   return new Promise<boolean>((resolve) => {
     navigator.geolocation.getCurrentPosition(
       (position) => {
         setHasLocationPermission(true)
         setUserLocation({
           lat: position.coords.latitude,
           lng: position.coords.longitude
         })
         resolve(true)
       },
       (error) => {
         console.error('Location permission error:', error)
         let errorMsg = 'Unable to access location'
         
         switch(error.code) {
           case error.PERMISSION_DENIED:
             errorMsg = isIOS 
               ? 'Please enable Location Services in Settings'
               : 'Please allow location access in your browser settings'
             break
           case error.POSITION_UNAVAILABLE:
             errorMsg = 'Location information unavailable'
             break
           case error.TIMEOUT:
             errorMsg = 'Location request timed out'
             break
         }
         
         setLocationError(errorMsg)
         resolve(false)
       },
       {
         enableHighAccuracy: true,
         timeout: 10000,
         maximumAge: 0
       }
     )
   })
 }, [isIOS])

 const updateUserMarker = useCallback((position: google.maps.LatLngLiteral, mapInstance: google.maps.Map) => {
   if (!userMarker) {
     const marker = new google.maps.Marker({
       position,
       map: mapInstance,
       icon: {
         path: google.maps.SymbolPath.CIRCLE,
         scale: 8,
         fillColor: "#4CAF50",
         fillOpacity: 1,
         strokeWeight: 2,
         strokeColor: "#ffffff",
       },
       title: "Your Location",
       zIndex: 999
     })
     setUserMarker(marker)
   } else {
     userMarker.setPosition(position)
   }
 }, [userMarker])

 const startLocationTracking = useCallback(async (mapInstance: google.maps.Map) => {
   if (!hasLocationPermission) {
     const granted = await requestLocationPermission()
     if (!granted) return
   }

   // Get initial position
   navigator.geolocation.getCurrentPosition(
     async (position) => {
       const userPos = {
         lat: position.coords.latitude,
         lng: position.coords.longitude
       }
       
       setUserLocation(userPos)
       setLocationEnabled(true)
       updateUserMarker(userPos, mapInstance)

       if (navigationMode) {
         mapInstance.panTo(userPos)
         mapInstance.setZoom(16)
       }

       // Start continuous tracking
       const id = navigator.geolocation.watchPosition(
         async (newPosition) => {
           const newPos = {
             lat: newPosition.coords.latitude,
             lng: newPosition.coords.longitude
           }

           setUserLocation(newPos)
           updateUserMarker(newPos, mapInstance)

           if (nearbyShops.length > 0 && currentStep < nearbyShops.length) {
             const nextDestination = nearbyShops[currentStep]
             const distance = google.maps.geometry.spherical.computeDistanceBetween(
               new google.maps.LatLng(newPos.lat, newPos.lng),
               new google.maps.LatLng(nextDestination.latitude, nextDestination.longitude)
             )

             if (distance < 50) {
               setIsAtDestination(true)
             }
           }

           if (navigationMode) {
             mapInstance.panTo(newPos)
           }

           if (routeSteps.length > 0) {
             const lastPos = userLocation
             if (lastPos) {
               const movement = google.maps.geometry.spherical.computeDistanceBetween(
                 new google.maps.LatLng(lastPos.lat, lastPos.lng),
                 new google.maps.LatLng(newPos.lat, newPos.lng)
               )
               if (movement > 50) {
                 await calculateRoute()
               }
             }
           }
         },
         (error) => {
           console.error("Location tracking error:", error)
           setLocationError("Failed to track location")
         },
         {
           enableHighAccuracy: true,
           timeout: 10000,
           maximumAge: 5000
         }
       )

       setWatchId(id)
     },
     (error) => {
       console.error("Initial location error:", error)
       setLocationError("Failed to get initial location")
     }
   )
 }, [hasLocationPermission, requestLocationPermission, navigationMode, nearbyShops, currentStep, updateUserMarker, routeSteps.length, calculateRoute])


 return (
   <div className="flex flex-col space-y-4">
     <Card className="p-4 w-full">
       <div className="flex flex-col space-y-4">
         {locationError && (
           <Alert variant="destructive">
             <AlertDescription>{locationError}</AlertDescription>
           </Alert>
         )}

         {(!locationEnabled && !navigationMode) && (
           <Button 
             onClick={() => startLocationTracking(map!)}
             className="w-full mb-4"
             disabled={isCalculating}
           >
             <Lock className="mr-2 h-4 w-4" />
             {isIOS ? "Enable Location Services" : "Enable Location Access"}
           </Button>
         )}

         <div className="w-full">
           <RadioGroup
             defaultValue={transportMode}
             onValueChange={(value) => {
               setTransportMode(value as 'DRIVING' | 'WALKING')
               if (routeSteps.length > 0) {
                 calculateRoute()
               }
             }}
             className="flex justify-center sm:justify-start gap-4"
           >
             <div className="flex items-center space-x-2">
               <RadioGroupItem value="DRIVING" id="driving" />
               <Label htmlFor="driving" className="flex items-center gap-2">
                 <Car className="h-4 w-4" /> Driving
               </Label>
             </div>
             <div className="flex items-center space-x-2">
               <RadioGroupItem value="WALKING" id="walking" />
               <Label htmlFor="walking" className="flex items-center gap-2">
                 <Navigation className="h-4 w-4" /> Walking
               </Label>
             </div>
           </RadioGroup>
         </div>

         <div className="grid grid-cols-2 sm:grid-cols-4 gap-2">
           {locationEnabled && (
             <>
               <Button
                 variant="outline"
                 size="sm"
                 onClick={() => setShowUserLocation(!showUserLocation)}
                 className="w-full"
               >
                 <User className="h-4 w-4 mr-2" />
                 {showUserLocation ? "Hide" : "Show"} Location
               </Button>
               
               <Button
                 variant="outline"
                 size="sm"
                 onClick={() => calculateRoute()}
                 disabled={isCalculating || !hasLocationPermission}
                 className="w-full"
               >
                 <Map className="h-4 w-4 mr-2" />
                 {isCalculating ? "Calculating..." : "Calculate Route"}
               </Button>

               {routeSteps.length > 0 && (
                 <>
                   <Button 
                     onClick={() => {
                       setNavigationMode(true)
                       setCurrentStep(0)
                     }}
                     variant="secondary"
                     className="w-full"
                   >
                     <Navigation className="h-4 w-4 mr-2" />
                     Start Navigation
                   </Button>
                 </>
               )}
             </>
           )}
         </div>

         {navigationMode && (
           <div className="grid grid-cols-3 gap-2">
             <Button 
               variant="outline"
               onClick={() => handlePreviousLocation()}
               disabled={currentStep === 0}
               className="w-full"
             >
               <ChevronLeft className="h-4 w-4 mr-2" />
               Previous
             </Button>
             
             <Button
               variant="outline"
               onClick={() => handleNextLocation()}
               disabled={currentStep === nearbyShops.length - 1}
               className="w-full"
             >
               Next
               <ChevronRight className="h-4 w-4 ml-2" />
             </Button>
             
             <Button 
               onClick={() => {
                 setNavigationMode(false)
                 setCurrentStep(0)
                  setIsAtDestination(false)
                }}
                variant="outline"
                className="w-full"
              >
                Exit
              </Button>
            </div>
          )}
        </div>
      </Card>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-4">
        <div className="lg:col-span-2 space-y-4">
          <div
            id="route-map"
            className="h-[50vh] sm:h-[60vh] lg:h-[700px] w-full rounded-lg border bg-muted"
          />
        </div>

        <div className="lg:col-span-1">
          {navigationMode ? (
            <NavigationPanel
              currentLocation={nearbyShops[currentStep]}
              nextLocation={nearbyShops[currentStep + 1]}
              currentStep={currentStep}
              totalSteps={nearbyShops.length}
              routeSteps={routeSteps}
              transportMode={transportMode}
              onStepChange={async (newStep) => {
                setCurrentStep(newStep)
                setIsAtDestination(false)
                if (map && nearbyShops[newStep]) {
                  const targetLocation = nearbyShops[newStep]
                  map.panTo({ lat: targetLocation.latitude, lng: targetLocation.longitude })
                  map.setZoom(16)
                  await calculateRoute()
                }
              }}
              onLocationUpdate={async (updatedLocation) => {
                try {
                  const response = await fetch(`/api/coffee-shops/${updatedLocation.id}`, {
                    method: 'PATCH',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify(updatedLocation)
                  })

                  if (!response.ok) throw new Error('Failed to update location')

                  toast({
                    title: "Success",
                    description: "Location information updated."
                  })

                  if (map) {
                    addShopMarkers(map)
                    await calculateRoute()
                  }
                } catch (error) {
                  toast({
                    title: "Error",
                    description: "Failed to update location.",
                    variant: "destructive"
                  })
                }
              }}
              onLocationVisited={handleLocationVisited}
              onLocationSkipped={() => {
                setCurrentStep(prev => prev + 1)
                setIsAtDestination(false)
              }}
              onExitNavigation={() => {
                setNavigationMode(false)
                setCurrentStep(0)
                setIsAtDestination(false)
              }}
              onPreviousLocation={handlePreviousLocation}
              onNextLocation={handleNextLocation}
              isAtDestination={isAtDestination}
              arrivalTime={estimatedArrival}
              timeRemaining={timeRemaining}
              className="h-[calc(50vh-4rem)] sm:h-auto overflow-y-auto"
            />
          ) : (
            <Card className="p-4">
              <div className="space-y-4">
                <div className="flex items-center justify-between">
                  <h3 className="font-semibold">Visit Order</h3>
                  <span className="text-sm text-muted-foreground">
                    {nearbyShops.length} locations
                  </span>
                </div>

                <div className="flex items-center gap-2 p-2 rounded-lg bg-muted">
                  <div className="w-8 h-8 rounded-full bg-primary/10 flex items-center justify-center">
                    <span className="font-medium text-primary">S</span>
                  </div>
                  <div className="min-w-0 flex-1">
                    <p className="font-medium truncate">{sourceShop.title}</p>
                    <p className="text-sm text-muted-foreground truncate">Starting Point</p>
                  </div>
                </div>

                <div className="space-y-2 max-h-[50vh] overflow-y-auto">
                  {nearbyShops.map((shop, index) => (
                    <div
                      key={shop.id}
                      className="flex items-center gap-2 p-2 rounded-lg hover:bg-muted/50 transition-colors"
                    >
                      <div className="w-8 h-8 rounded-full bg-primary/10 flex items-center justify-center flex-shrink-0">
                        <span className="font-medium">{index + 1}</span>
                      </div>
                      <div className="flex-1 min-w-0">
                        <p className="font-medium truncate">{shop.title}</p>
                        <p className="text-sm text-muted-foreground truncate">
                          {shop.address}
                        </p>
                      </div>
                      {shop.visited && (
                        <Badge variant="success" className="flex-shrink-0">
                          Visited
                        </Badge>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            </Card>
          )}
        </div>
      </div>
    </div>
  )
}
